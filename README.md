# jorgOS
Self-education and pet project in which I have done, among many other things, the following things myself:
* made my own minimal RTOS with threading and event-handling capabilities.
* set up the entire development toolchain in VS Code for ARM embedded development for ARM in C.
* developed a Board Support Package(BSP) for the TM4C123GH6PM chip on the
  TM4C123GXL development board
* interfaced with various electronic/electrical components.

**All code except some startup code provided by Texas Instruments, is my own.**
But still, some startup code was altered or written by me.

Disclaimer: _the code you will see is an first effort to get things done, the
code is not cleaned up when I understand the underlying embedded development
concept well enough to move to the next learning goal. It is not an effort to demonstrate
clean coding skills. ;) The code is also littered with comments where I "talk to
myself" when trying to learn what is going on. I found it to be helpful for
education purposes, but it does make for a lot of comments that are not always useful._

# Current state and overview of capabilities

In its current form the project is nothing more than world's most needlessly complex "blinky" program , which alters the LED colours and blinking modes based on switch and
rotary knob inputs. I went out of my way to learn fundamental concepts along the
way, so this is what happens:

The rough code flow is as follow:.

We enter `main()` and call:

  - `BSP_init()` to initialize the Board Support Package, which initializes:
      - GPIO modules for various components, such as the switches.
      - PWM modules to drive the LEDS.
      - UART for the Serial Monitor
      - A timer for dynamic changes in LED effects.
      - The Quadrature Encoder Interface (QEI) 
  - `LM_init()`:
      - Initialization of the Led Manager that allows for switching between
        fancy LED modes.
  - `OS_init()` to initialize "jorgOS", the self-made multi-threaded operating system.
      - Set the priority of the PendSV interrupt to the lowest level, to
        ensure other interrupts complete first.
      - Enable the Critical Section Manager to allow the OS to properly deal with
        nested critical sections.
      - Register the idle thread, which contains a callback to a user-defined
        `OS_onIdle()` function for dealing with low priority tasks, such as
        sending the pending characters from the Serial Monitor buffer over
        UART, and putting the microcontroller in low-power mode until.
  - `J_sema_init()` and `J_Mutex_init()` to initialize the semaphores and
    mutexes that will be used by the threads.

  - `OS_EventQueue_Thread_start()` and `BSP_register_EQT_thread()` to register
    the special EventQueue Thread that handles events generated by the BSP.
  - `OS_Thread_start()` to register various threads:
      - Several dummy threads that used to blink different parts of the LGB to
        demonstrate that the jorgOS scheduler is working, and correctly prioritizing
        and delaying threads. A logic analyser was used to show correct
        behaviour. LED behaviour has since moved to the PWM.
      - Several threads to test proper working of semaphores and mutexes of, and
        that threads are blocked/unblocked with correct priority and timing.

- `OS_run()`
    - Enters a critical section
    - Calls `OS_onStartup()` in the Board Support Package to enable the SysTick
      interrupt. The SysTick_Handler will execute:
      - `OS_tick()`, which updates the timers that delay the threads.
      - `BSP_tick()` to check peripherals and potentially post BSP events based
        on the changed state of debounced buttons and rotary knobs.
      - `OS_schedule()` to schedule the first thread.
    - Exiting the critical section, which allows the PendSV Interrupt to
      trigger, which does the context switch between threads.

`OS_run()` is never returned from, as the context never switches back and
control is handed over the the created threads. The OS only intervenes through
interrupts and scheduling new threads from this point on.

# Detailed list of features, things learned and/or debugged

A list to showcase in more detail what has been done and or/learned.

- Setting up a development toolchain
  - Configuring VS Code to work with:
    - `armclang`
    - Debugging the target with the generated `.axf` file.
  - Makefiles
    - Compiling
    - Linking 
    - Dependency file generation
    - Flashing
    - Cleaning
  - Self-made testing framework
    - Implemented with convenient preprocessor macros for defining test groups
      and test-cases.
    - Can run on both host and target device
      - Call-backs implemented in BSP to monitor test progress over Serial
        Monitor when running on the target device
  - Macro-based asserts through-out the code to achieve some form of
    design-by-contract approach.
      - Can later be reconfigured for fault detection and recovery.

- C

  _Too much to keep track of, so this is a selection of not too basic stuff:_
  - OOP in C with structs.
    - Encapsulation with `typedef struct` and clear namespacing.
    - Composition
    - Inheritance
    - Virtual functions through virtual tables
  - First In First Out(FIFO) Ring buffers
  - Fixed-point arithmetic
    - Macro-based
    - HSL-to-RGB conversion based
  - Math utility functions
  - Forward declarations to break cyclic dependencies.
  - Name-spacing own functions to avoid potential clashes.
  - Overriding `fputc()` to make `printf()` use the self-made Serial Monitor
  - ARM procedure call standard (APCS)
  - Correctly using pointers when:
    - Up/down-casting to achieve inheritance
    - Function handlers
    - Using pointer arithmetic for ring buffers
    - Using more complex typedefs

- Assembly / assembler
  - For the context switch in the PendSV Handler.
  - To monitor the integrity of the stack (pointer) of threads.
  - To access instructions like CLZ(Count Leading Zeros)
  - Start-up file:
    - Vector Table
    - Allocating stack and heap regions.
- Self-made RTOS called jorgOS with hybrid scheduling concepts:
  - Event-based scheduling with Run-To-Completion (RTC) tasks
    - Use of locking mechanisms prohibited by OS during event execution
  - Pre-emptive scheduler with:
    - Priority-based
    - Delay/sleep functions
    - Mutexes
    - Semaphores
  - Nested critical sections

- Peripherals
  - Implemented through the Board Support Package(BSP) design pattern.
  - GPIO
    - Configuring protected pins
    - Setting alternative functions
    - Setting Pull-up and Pull-down resistors
  - Pulse-Width Modulation (PWM) driving LEDs
    - Dead bands
    - Setting clocks and duty cycles
  - Debounced buttons
  - Quadrature Encoder Interface
    - Filtering signal to remove noise from rotary encoder signal
  - General Purpose Timers
    - Used for managing periodic events
  - UART
    - Used for the serial monitor

- Debugging
  - Checking register contents and understanding their specific purposes
  - Monitoring through serial monitor
  - Attaching a Logic Analyser
  - Example of problems that were solved:
    - Debugged apparent broken context-switch after switching the toolchain.
      Turned out to be that FPU settings were not as expected, which affects
      what is and must be pushed onto the stack. This was found out by closely
      inspecting the Link Register and noticing the MCU was not running in the
      expected FPU mode based on its contents.
  - Design-by-contract style asserts







  


    


